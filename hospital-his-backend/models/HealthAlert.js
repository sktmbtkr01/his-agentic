/**
 * Health Alert Model
 * Stores proactive alerts generated by the Predictive Intelligence system
 * Includes anomaly detection and trend analysis alerts
 */

const mongoose = require('mongoose');

// Alert severity levels
const ALERT_SEVERITY = {
    LOW: 'low',
    MEDIUM: 'medium',
    HIGH: 'high',
    CRITICAL: 'critical',
};

// Alert types
const ALERT_TYPES = {
    // Anomaly-based alerts
    VITAL_ANOMALY: 'vital_anomaly',
    SYMPTOM_PATTERN: 'symptom_pattern',
    MOOD_DECLINE: 'mood_decline',
    SLEEP_DISRUPTION: 'sleep_disruption',
    ACTIVITY_CHANGE: 'activity_change',

    // Trend-based alerts
    DECLINING_SCORE: 'declining_score',
    VITAL_TREND: 'vital_trend',
    CHRONIC_SYMPTOM: 'chronic_symptom',

    // Predictive alerts
    RISK_PREDICTION: 'risk_prediction',
    HEALTH_MILESTONE: 'health_milestone',
};

// Alert status
const ALERT_STATUS = {
    ACTIVE: 'active',
    ACKNOWLEDGED: 'acknowledged',
    DISMISSED: 'dismissed',
    RESOLVED: 'resolved',
    EXPIRED: 'expired',
};

const healthAlertSchema = new mongoose.Schema(
    {
        // Patient reference
        patient: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Patient',
            required: [true, 'Patient reference is required'],
            index: true,
        },

        // Alert classification
        type: {
            type: String,
            enum: Object.values(ALERT_TYPES),
            required: [true, 'Alert type is required'],
            index: true,
        },

        severity: {
            type: String,
            enum: Object.values(ALERT_SEVERITY),
            required: [true, 'Alert severity is required'],
            index: true,
        },

        // Alert content
        title: {
            type: String,
            required: [true, 'Alert title is required'],
            maxlength: 200,
        },

        message: {
            type: String,
            required: [true, 'Alert message is required'],
            maxlength: 1000,
        },

        // Contextual data
        context: {
            // The metric or signal that triggered the alert
            metric: String,

            // Current value that caused the alert
            currentValue: mongoose.Schema.Types.Mixed,

            // Expected/normal range
            expectedRange: {
                min: Number,
                max: Number,
            },

            // Trend data if applicable
            trend: {
                direction: {
                    type: String,
                    enum: ['increasing', 'decreasing', 'stable', 'volatile'],
                },
                percentChange: Number,
                duration: String, // e.g., "7 days"
            },

            // Related data points
            dataPoints: [{
                timestamp: Date,
                value: mongoose.Schema.Types.Mixed,
            }],

            // Confidence score (0-100)
            confidence: {
                type: Number,
                min: 0,
                max: 100,
            },
        },

        // Recommended actions
        recommendations: [{
            type: {
                type: String,
                enum: ['log_signal', 'consult_doctor', 'lifestyle_change', 'medication', 'emergency', 'monitor'],
            },
            action: String,
            route: String, // Frontend route if applicable
            priority: {
                type: Number,
                default: 1,
            },
        }],

        // Alert status
        status: {
            type: String,
            enum: Object.values(ALERT_STATUS),
            default: ALERT_STATUS.ACTIVE,
            index: true,
        },

        // User interaction tracking
        interaction: {
            acknowledgedAt: Date,
            dismissedAt: Date,
            resolvedAt: Date,
            feedback: {
                helpful: Boolean,
                comment: String,
            },
        },

        // Expiration
        expiresAt: {
            type: Date,
            index: true,
        },

        // Source of alert
        source: {
            type: String,
            enum: ['anomaly_detection', 'trend_analysis', 'ml_prediction', 'rule_based'],
            default: 'anomaly_detection',
        },

        // Related alerts (for grouping similar alerts)
        relatedAlerts: [{
            type: mongoose.Schema.Types.ObjectId,
            ref: 'HealthAlert',
        }],

        // Metadata for deduplication
        fingerprint: {
            type: String,
            index: true,
        },
    },
    {
        timestamps: true,
        toJSON: { virtuals: true },
        toObject: { virtuals: true },
    }
);

// Indexes
healthAlertSchema.index({ patient: 1, status: 1, createdAt: -1 });
healthAlertSchema.index({ patient: 1, type: 1, createdAt: -1 });
healthAlertSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 }); // TTL index

// Virtual: Is alert actionable
healthAlertSchema.virtual('isActionable').get(function () {
    return this.status === ALERT_STATUS.ACTIVE &&
        (!this.expiresAt || new Date() < this.expiresAt);
});

// Virtual: Time since creation
healthAlertSchema.virtual('age').get(function () {
    const now = new Date();
    const diff = now - this.createdAt;
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (hours < 1) return 'Just now';
    if (hours < 24) return `${hours}h ago`;
    if (days < 7) return `${days}d ago`;
    return this.createdAt.toLocaleDateString();
});

// Static: Get active alerts for patient
healthAlertSchema.statics.getActiveAlerts = async function (patientId, options = {}) {
    const { limit = 10, types, severity } = options;

    const query = {
        patient: patientId,
        status: ALERT_STATUS.ACTIVE,
        $or: [
            { expiresAt: { $exists: false } },
            { expiresAt: { $gt: new Date() } },
        ],
    };

    if (types && types.length > 0) {
        query.type = { $in: types };
    }

    if (severity) {
        query.severity = severity;
    }

    return this.find(query)
        .sort({ severity: -1, createdAt: -1 })
        .limit(limit);
};

// Static: Check for duplicate alert
healthAlertSchema.statics.isDuplicate = async function (patientId, fingerprint, hoursWindow = 24) {
    const windowStart = new Date();
    windowStart.setHours(windowStart.getHours() - hoursWindow);

    const existing = await this.findOne({
        patient: patientId,
        fingerprint,
        createdAt: { $gte: windowStart },
        status: { $in: [ALERT_STATUS.ACTIVE, ALERT_STATUS.ACKNOWLEDGED] },
    });

    return !!existing;
};

// Method: Acknowledge alert
healthAlertSchema.methods.acknowledge = async function () {
    this.status = ALERT_STATUS.ACKNOWLEDGED;
    this.interaction.acknowledgedAt = new Date();
    return this.save();
};

// Method: Dismiss alert
healthAlertSchema.methods.dismiss = async function (feedback = null) {
    this.status = ALERT_STATUS.DISMISSED;
    this.interaction.dismissedAt = new Date();
    if (feedback) {
        this.interaction.feedback = feedback;
    }
    return this.save();
};

// Method: Resolve alert
healthAlertSchema.methods.resolve = async function () {
    this.status = ALERT_STATUS.RESOLVED;
    this.interaction.resolvedAt = new Date();
    return this.save();
};

// Pre-save: Generate fingerprint if not set
healthAlertSchema.pre('save', function (next) {
    if (!this.fingerprint) {
        // Create fingerprint from type + metric + date (day granularity)
        const dateStr = this.createdAt ?
            this.createdAt.toISOString().split('T')[0] :
            new Date().toISOString().split('T')[0];
        this.fingerprint = `${this.type}_${this.context?.metric || 'general'}_${dateStr}`;
    }
    next();
});

const HealthAlert = mongoose.model('HealthAlert', healthAlertSchema);

module.exports = {
    HealthAlert,
    ALERT_TYPES,
    ALERT_SEVERITY,
    ALERT_STATUS,
};
